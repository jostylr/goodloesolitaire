/*globals $, module, console, require, process*/

var events = require('events');
var logs = require('./lib/logging.js');
var queryengine = require('query-engine');  


var file = 'utilities/inventory';

var prepargs, makechanges, wrapper, wrapper_debug, delayedemit;


var Dispatcher = function () {
  var evem = this;
   
  //action object
  evem.a = {};
  
  //transforms object
  evem.t = {};
  
  //log/debug 
  evem.logtypes = {};
  evem.logtypes['default active'] = logs.con;
  evem.logtypes['nolog'] = logs.noop;
  
  //initially no debug
  evem.log = evem.logtypes['nolog'];
  
  
  evem.install("inventory", { //action functions
    "turn on debugging" :  function (type) {
      type = type || 'default active';
      evem.log = evem.logtypes[type];
      return {$$emit : "debugging turned on"};
    },
    "turn off debugging" : function () {
      evem.log = evem.logtypes['nolog'];
      return {$$emit : "debugging turned off"};
    }
  } );
  
  evem.ret( { $$on : {
    "debugging requested" : [
      "turn on debugging" 
    ],
    "debugging turned on" : [
    ],
    "debugging off, please" : [
      "turn off debugging"
    ],
    "debugging turned off" : [
    ]
  } } );

  
  //data storage
  evem.data = new queryengine.Collection();
  evem.store = {};  //for non-JSON able stuff, record it by using $$store : "..."

};

Dispatcher.prototype = new events.EventEmitter(); 

module.exports.Dispatcher = Dispatcher;


Dispatcher.prototype.install = function (file, a) {
  var evem = this;
  var eva = this.a;
  var f, g;
  
  var fname, entry, args; 

  for (fname in a) {
    if (eva.hasOwnProperty(fname)) {
      console.log("duplicate name: "+fname+"from "+ file+", old: "+eva.fname.desc);
    }
    entry = a[fname];
    if ($.isArray(a[fname])) {
      //[args, function]
      args = entry[0];
      f = entry[1];
    } else {
      args = false;
      f = entry;
    }
    g = evem.wrapper(f, args);      
    eva[fname] = g;
    g.desc = file+fname;
    f.desc = file+fname;       
  }
  
  
};

Dispatcher.prototype.retrieve = function (name) {
  return this.store[name];
};

//return function
Dispatcher.prototype.ret = function (changes, desc) {
    console.log(this, changes, desc);
    this.log.makechanges(desc || "no description", changes);
    this.makechanges(changes);
  };

Dispatcher.prototype.wrapper =  function (f, args) {
  var evem = this;
  return function me () {
    var changes, doneargs;
    evem.log.action(f, args);
    if (!args) {
      changes = f.call(evem);
    } else {
      doneargs = evem.prepargs(args);
      evem.log.prepargs(me.desc, doneargs);
      changes = f.apply(evem, doneargs);
    }
    if (changes) {
      evem.log.makechanges(me.desc, changes);
      evem.makechanges(changes);
    }
  };
};


Dispatcher.prototype.prepargs = function (args) {
  var evem = this;
  var i, n, current, value, key;
  var values = [];
  var data = evem.data;
  var store = evem.store;
  n = args.length;
  for (i = 0; i < n; i += 1) {
    current = args[i];
    if (typeof current === "string") {
      //data name
      if (data.hasOwnProperty(current)) {
        values.push(data[current]);
      } else {
        values.push(undefined);
      }
    } else {
      //assuming data object
      if (current.hasOwnProperty("$$default")) {
        value = current.$$default;
      } else {
        value = undefined;
      }
      if (current.hasOwnProperty("$$transform")) { //fix transform. do key:value with value possibly an array of actions to take after event.
       if (current.$$transform.length === 2) { //simple case
         key = current.$$transform[1];
         if (data.hasOwnProperty(key)) {
           value = current.$$transform[0](data[key]);
         }
       }
      }
      if (current.hasOwnProperty("$$get")) {
        key = current.$$get;
        if (data.hasOwnProperty(key)) {
          value = data[key];
        }
      }
      if (current.hasOwnProperty("$$retrieve")) {
        key = current.$$retrieve;
        if (store.hasOwnProperty(key)) {
          value = "retrieve:" +  key;
        }
      }
      values.push(value);
    }
  }
  return values; 
};

Dispatcher.prototype.delayedemit = function (evnt) {
  var evem = this;
  if (typeof evnt === "string") { //even with no data
    process.nextTick(function () {evem.emit(evnt);});
  } else { //event with arguments
    process.nextTick(function () {evem.emit.apply(evem, evnt);});    
  }
};

Dispatcher.prototype.makechanges = function (changes) {
  var evem = this;
  var data = evem.data;
  var a = evem.a;
  var key, i, n, evnt, type, current, pe;
  //command structure
  try {
  if (changes.hasOwnProperty("$set")) {
    for (key in changes.$set) {
      data[key] = changes.$set[key];
    }
  }
  if (changes.hasOwnProperty("$unset")) {
    for (key in changes.$unset) {
      delete data[key];
    }
  }
  if (changes.hasOwnProperty("$inc")) {
    for (key in changes.$inc) {
      data[key] += changes.$inc[key];
    }
  }
  if (changes.hasOwnProperty("$$emit")) {
    if (typeof changes.$$emit === "string" ) {
      evem.delayedemit(changes.$$emit); 
      evem.log.emit(changes.$$emit);
    } else { //presumably array
      n = changes.$$emit.length;
      for (i = 0; i < n; i += 1) {
        evem.delayedemit(changes.$$emit[i]);
        evem.log.emit(changes.$$emit[i]);
      }      
    }
  }
  if (changes.hasOwnProperty("$$emitnow")) {
    if (typeof changes.$$emitnow === "string" ) {
      evem.emit(changes.$$emitnow);              
      evem.log.emitnow(changes.$$emit);
    } else { //presumably array
      n = changes.$$emitnow.length;
      for (i = 0; i < n; i += 1) {
        evnt = changes.$$emitnow[i];
        if (typeof evnt === "string" ){
          evem.emit(evnt);
          evem.log.emitnow(evnt);
        } else {
          evem.emit.apply(evem, evnt);
          evem.log.emitnow(evnt);
        }
      }      
    }
  }
  
  for (type in {"$$once" : 1, "$$on" : 1, "$$removeListener" : 1 }) {
    if (changes.hasOwnProperty(type)) {
      pe = type.slice(2);
      for (key in changes[type]) {        
        current = changes[type][key];
        if (typeof current === "string") {
          evem[pe](key, a[current]);
          evem.log[pe](key, current);
        } else { //array
          n = current.length;
          for (i = 0; i < n; i += 1) {
            evem[pe](key, a[current[i]]);
            evem.log[pe](key, current[i]);
          }
        }
      }
   /*   n = changes[type].length;
      for (i = 0; i < n; i += 1) {
        evnt = changes[type][i];
        evem.once(evnt[0], a[evnt[1]]);
      }*/
    }    
  }  
  
} catch (e) {
  console.log(e);
}
  
  
  return false; 
};